# lab2实验报告

(我不觉得我能在200字以内讲完我干了啥)

## 需要修改的代码

### 重写 sys_get_time 和 sys_task_info

由于使用了虚拟地址，因此，这两个函数得到的参数，是相应任务的虚拟地址，而这两个函数本身是运行在内核空间内的。首先需要得到这两个函数参数指针的实际地址，随后把内容写入到那里去。

对于该实际地址，使用PageTable：：from_token得到一个手动查找的页表。同时使用find_pte和translate获得参数指针所在的物理页表，然后和物理页表的最后12位进行或运算，得到参数指针的实际物理地址。

随后的内容和lab1里面基本一样。

因为两个函数得到物理地址的过程一样，所以可以另外写一个函数来减少代码量。

### mmap 和 munmap 匿名映射

对于这两个函数，首先需要根据任务提示，检查插入的各个参数。

随后，这两个函数需要在对应的任务的task ctr block中，新建一串映射。因此，首先需要找到对应的任务控制块，随后添加一串地址到对应的task里面的memset里面。同时，需要检查是否对应的块已经映射到某个虚拟块上面了

munmap则是相反的过程。这里面同样需要检查是否某个虚拟块已经映射过去了。

（关于这个部分，我努力了半天，试图在syscall而不是task模块里面完成，但看上去并不太方便，原因是，memset没法复制...，所以最后还是写进task模块算了。）

关于如何检查某个块是否已经映射进某个虚拟块，需要遍历所有的MapArea，查看每个MapArea是否包含进该块，所以，还需要在memset里面插入对应的代码。这个代码在这两个函数中都有用，只不过一个关注false，一个关注true

一个需要注意的事情，正如实验任务提示的那样，port和permission的参数是完全不一样的。这里面需要进行格式的转换

另一个我认为需要说明白的是，发现一块释放一块，而不是全都发现全都释放——这个看看unmap测试样例就知道了。

另一个比较吊诡的事情，是unmap过程，没有任何保证能够保证unmap的集合，和某一次mmap的集合能够完全相同，也就是说，试图unmap的那个区间，有可能，跨越两个area（当然多个也有可能，这就不要杠了），所以需要先找到，然后unmap对应的那个块。

那么，如果在某个area中间，是否需要分裂那个area呢，以及，当某个area全部清空了之后是否需要释放该area呢？算了我不想干了，何必给自己添麻烦！

